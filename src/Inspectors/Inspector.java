package Inspectors;

import java.util.Vector;
import java.lang.reflect.*;
import java.util.Arrays;

/**
 * Referenced from Assignment 2 (and all dependency references including Jordan Kidney).
 * Refer to https://github.com/vektor-knight/CPSC501_A2-0/tree/finalBranch/src
 * @author shshunda
 */
public class Inspector {
    
    public Inspector() {
        
    }
    /*
    Does this need a constructor? Perhaps
    some variables can be abstracted out.
    */
    
    public void inspect(Object obj, boolean recursive) {
        // Following Jordan Kidney's "ObjectInspector.java",
        // use a Vector as a data structure for storing objects
        Vector objectsToInspect = new Vector();
        
        // Create instance of a class object based on the method input
        // To be used for every subsequent introspection.
        Class classObject = obj.getClass();
        
        /*
         * Programming Plan, before applying any refactoring
         * or unit testing. Most of these are just library method calls.
         * Referencing the Java library: (java.lang.reflect)
         */
        // Name of the declaring class
        System.out.println("INSPECTING THE DECLARING CLASS");
        System.out.println("The declaring class is: " + classObject.getSimpleName());
        System.out.println("DONE INSPECTING THE DECLARING CLASS");
        
        // Name of the declaring superclass
            // Using refactoring of getting superclass.
        System.out.println("INSPECTING THE DECLARING CLASS");
        // Attempted to use my wrapper method with getSimpleName().
        // Invoked getSuperclass directly. (Refactor: change method)
        System.out.println("Its superclass is: " + classObject.getSuperclass().getSimpleName());
        System.out.println("DONE INSPECTING THE DECLARING CLASS");

        // Passes with recursive == false
        inspectInterfaces(obj, classObject);
        inspectMethods(obj, classObject);
        inspectConstructor(obj, classObject);
        // Since no further interface metadata is required,
        // we satisfy the interface requirement by just using
        // the reflective methods to get the interface names.
        // Reference: ObjectInspector.java by Jordan Kidney
        // Used to mitigate programming time: used to inspect field values.
        // We will not be making recursive calls.
        ObjectInspector o = new ObjectInspector();
        o.inspect(obj, recursive);
        
        // Complete recursive calling here, using https://github.com/stevarms/CPSC501A2/blob/master/src/Inspector.java
        if ((classObject.getSuperclass() != null) && (classObject.getSuperclass() != Object.class)) {
            inspectSuperClass(obj, classObject, objectsToInspect);
        }
        
      //  if (recursive) o.inspectFieldClasses(obj, classObject, objectsToInspect, recursive);
    }
    
        // At this point, unit tests are required.
    // Autogenerated using IDE.
    
    // Since getting the interfaces of a class is entailed
    // by traversing an array containing elements of type Class,
    // two methods will be required. The first will traverse 
    // the array, and the second will be a wrapper which
    // returns strings of those Class elements.
    // There might be a way to get this into one form.
    public Class[] getClassInterfaces(Class x) {
        // Name of the interfaces the class implements
        Class classObject = x.getClass();
        Class[] classInterfaces = classObject.getInterfaces();
        return classInterfaces;
        // Since the interfaces are returned in an array,
        // traverse it.
        // In this case, we are only asked for the name, although
        // it is possible to retrieve other data about the interfaec
        // after each iteration.
    }
        
            // Methods the class declares
    // In the final version, the idea is to be able to
    // take this array containing elements of type String,
    // and then print them one at a time, along with their constituent behaviour.
    public String getMethods(Class x) {
        Method[] methods = x.getMethods();
        String castedMethods = Arrays.toString(methods);
        return castedMethods;
    }
    
    // Get exceptions of a single method. 
    // Single method may have multiple exceptions.
    // Return them in an array of Strings.
    public String getExceptions(Method m) {
        Class[] excepts = m.getExceptionTypes();
        String exception = null;
        if (excepts.length > 0) {
            exception = null;
        } else {
            for (Class except : excepts) {
                exception += except.getSimpleName() + " ";
            }
        }
        return exception;
    }
    
    // Get parameters of a single method. Follows
    // the same structure as getExceptions(..).
    public String getParameters(Method m) {
        Class[] params;
        params = m.getParameterTypes();
        String parameter = null;
        if (params.length > 0) {
            parameter = null;
        } else {
            for (Class param : params) {
                parameter += param.getSimpleName() + " ";
            }
        }
        return parameter;
    }
    
    // Get return type
    // There is only ever one return type for
    // a given method.
    public Class<?> getReturnType(Method m) {
        Class<?> ret;
        ret = m.getReturnType();
        return ret;
    }
    
    // Helper to be used in getReturnType(..).
    // I think the refactoring when making
    // the query in getReturnType(..) is called
    // self encapsulate field. Not sure.
    public String getReturnString(Class<?> r, Method m) {
        r = getReturnType(m);
        String toString = r.toString();
        return toString;
    }
    
    // Get modifiers of a single method.
    public String getModifiers(Method m) {
        return Modifier.toString(m.getModifiers());
    }

    public String getConstructors(Class x) {
        Constructor[] c = x.getConstructors();
        return Arrays.toString(c);
    }
    
    // Get parameter types of a single Constructor
    public String getConstParams(Constructor x) {
        String params = Arrays.toString(x.getParameterTypes());
        return params;
    }
    
    // Get parameter modifiers of a single Constructor.
    public String getConstMods(Constructor x) {
        String mods = Modifier.toString(x.getModifiers());
        return mods;
    }
    
    // Now that the "base cases" have been tested, and we know that
    // it is possible to return basic information from introspection
    // of a single object... we can now create void methods with side-effects
    // which query the parsed String objects from the above methods.
    // We are guaranteed that the side-effects will produce correct
    // results, since unit tests were generated and hit with expected results.
    
    // The structure of the following void methods was referenced from:
    // https://github.com/stevarms/CPSC501A2/blob/master/src/Inspector.java
    
    public void inspectMethods(Object obj, Class classObject) {
        System.out.println("INSPECTING THE METHODS OF THE CLASS: " + classObject.getDeclaringClass());
        Method[] methods = classObject.getDeclaredMethods();
        if (methods.length > 0) {
            for (int i = 0; i < methods.length; i++) {
                Method x = methods[i];
                String y = getParameters(x);
                String a = getReturnString(classObject, x);
                String w = getModifiers(x);
                String z = getExceptions(x);
                
                System.out.println("The " + i + "th " + "method is: " + x.getName() 
                        + "\n\t Exception Types: " + z
                        + "\n\t Parameters: " + y 
                        + "\n\t Return Types: " + a
                        + "\n\t Modifiers: " + w ); 
            }
        } else {
            System.out.println("No methods exist for this class.");
        }
    }
    
    public void inspectConstructor(Object obj, Class classObject) {
        System.out.println("INSPECTING THE CONSTRUCTOR(S) OF THE CLASS: " + classObject.getSimpleName());
        Constructor[] c = classObject.getConstructors();
        if (c.length > 0) {
            for (int i = 0; i < c.length; i++) {
                Constructor x = c[i];
                String y = getConstParams(x);
                String z = getConstMods(x);
                System.out.println("The " + i + "th " + "method is: " + x.getName() +
                        "\n\t Parameters: " + y +
                        "\n\t Modifiers: " + z);
            }
        } else {
            System.out.println("No constructors exist for this class");
        }
    }
    
    public void inspectInterfaces(Object obj, Class classObj) {
        System.out.println("INSPECTING THE INTERFACE(S) OF THE CLASS : " + classObj.getSimpleName());
        Class[] inf = getClassInterfaces(classObj);
        if (inf.length > 0) {
            for (int i = 0; i < inf.length; i++) {
                Class x = inf[i];
                System.out.println("The " + i + "th " + "interface is: " + x.getName());
            } 
        } else {
            System.out.println("No interfaces exist for this class");
        }
    }
    
    // To handle recursion, used method from:
    // https://github.com/stevarms/CPSC501A2/blob/master/src/Inspector.java
    // Makes recursive calls on superclass and fields by traversing a Vector.
    // Incidentally, the pattern used here to achieve recursion is similar
    // to Jordan Kidney's solution in ObjectInspector.java.
    public void inspectSuperClass(Object obj, Class classObj, Vector objectsToInspect) {
        System.out.println("Recursively inspecting the superclasses available: " + classObj.getSimpleName());
        Class superClass = classObj.getSuperclass();
        inspectMethods(obj, superClass);
        inspectConstructor(obj, superClass);
        ObjectInspector o = new ObjectInspector();
        o.inspectFields(obj, superClass, new Vector());
    } 
    
        
}